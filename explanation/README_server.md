|Minitalk サーバー (server.c)|
|:----|
|このclient.cファイルは、Minitalkプロジェクトのサーバー側を実装しています。クライアントから送信されるSIGUSR1（1ビット）とSIGUSR2（0ビット）シグナルを受信し、それらのビットを組み立てて文字を再構築し、最終的にメッセージとして表示します。また、各文字を受信した後にクライアントに確認応答を送信します。|
|関数解説|
|このサーバープログラムで使用されている各関数について、詳しく見ていきましょう。|
|build_bit(int signal| unsigned char *current_char| int *bit_len)|
|目的: 受信したシグナル（SIGUSR1またはSIGUSR2）に基づいて、現在の文字を構成するビットを組み立てます。|
|パラメータ:|
|int signal: 受信したシグナルの種類（SIGUSR1またはSIGUSR2）。|
|unsigned char *current_char: 現在組み立て中の文字へのポインタ。ビットがこの変数に追加されます。|
|int *bit_len: 現在までに受信したビットの数へのポインタ。|
|メカニズム:|
|if (signal == SIGUSR1): 受信したシグナルがSIGUSR1（1を表す）の場合、*current_charの適切な位置に1を設定します。1 << (7 - *bit_len)は、現在のビット位置（最上位ビットから数えて）に1をシフトする操作です。|
|(*bit_len)++: ビットが1つ追加されたので、bit_lenをインクリメントします。|
|process_byte(unsigned char c)|
|目的: 完全に組み立てられた1バイト（1文字）を処理し、バッファに格納するか、メッセージが完了した場合は表示します。|
|パラメータ:|
|unsigned char c: 完全に組み立てられた文字。|
|メカニズム:|
|static char buf[4096]; と static int buf_idx = 0;: 受信した文字を一時的に保持するための静的バッファと、そのバッファの現在のインデックスを宣言します。staticキーワードにより、これらの変数は関数呼び出し間で値を保持します。|
|if (c == '\0'): 受信した文字がヌル終端文字（\0）の場合、メッセージの終わりを示します。|
|buf[buf_idx] = '\0';: バッファの現在の位置にヌル終端文字を追加し、文字列を終端させます。|
|ft_printf("%s\n"| buf);: 組み立てられたメッセージ全体を標準出力に表示します。|
|buf_idx = 0;: 次のメッセージのためにバッファインデックスをリセットします。|
|else: 受信した文字がヌル終端文字でない場合。|
|buf[buf_idx] = c;: 文字をバッファに格納します。|
|buf_idx++;: バッファインデックスをインクリメントします。|
|if (buf_idx >= (int)(sizeof(buf) - 1)): バッファがほぼ満杯になった場合（sizeof(buf) - 1はヌル終端文字のためのスペースを考慮）。|
|buf[buf_idx] = '\0';: バッファを終端させます。|
|ft_printf("%s"| buf);: バッファの内容を表示します（改行なし）。|
|buf_idx = 0;: バッファインデックスをリセットし、次の文字からバッファの先頭に書き込みを開始します。|
|handle_signal(int signal| siginfo_t *info| void *ucontext)|
|目的: クライアントからシグナルを受信したときに呼び出されるメインのシグナルハンドラ関数です。ビットの組み立て、文字の処理、およびクライアントへの確認応答の送信を管理します。|
|パラメータ:|
|int signal: 受信したシグナルの番号（SIGUSR1またはSIGUSR2）。|
|siginfo_t *info: シグナルに関する詳細情報（送信元プロセスのPIDなど）を含む構造体へのポインタ。|
|void *ucontext: シグナルが配信された時点のユーザーコンテキストを表す構造体へのポインタ（この関数では使用されません）。|
|メカニズム:|
|static unsigned char current_char = 0; と static int bit_len = 0;: 現在組み立て中の文字と、受信したビット数を追跡するための静的変数。|
|(void)ucontext;: ucontextパラメータが使用されないことをコンパイラに伝えます。|
|client_pid = info->si_pid;: シグナルを送信したクライアントのプロセスID (PID) を取得します。|
|build_bit(signal| &current_char| &bit_len);: 受信したシグナルを現在の文字に変換します。|
|if (bit_len == 8): 8ビット（1バイト）が完全に受信された場合。|
|process_byte(current_char);: 組み立てられた文字を処理します。|
|act_val.sival_int = 0;: sigqueueで送信する値（ここでは特に意味はないが、必須）。|
|if (sigqueue(client_pid| SIGUSR1| act_val) == -1): クライアントにSIGUSR1シグナルを送信して、文字の受信を確認したことを伝えます。sigqueueはkillよりも詳細な情報（sigval）を送信できます。|
|write(2| "Error: sigqueue failed\n"| 23);: sigqueueが失敗した場合、エラーメッセージを標準エラー出力に書き込みます。|
|current_char = 0;: 次の文字のためにcurrent_charをリセットします。|
|bit_len = 0;: 次の文字のためにbit_lenをリセットします。|
|main(void)|
|目的: サーバープログラムのエントリポイントです。サーバーのPIDを表示し、シグナルハンドラを設定し、無限ループに入ってシグナルを待ちます。|
|メカニズム:|
|struct sigaction sa;: シグナルハンドラの設定に使用するsigaction構造体を宣言します。|
|ft_printf("Server PID: %d\n"| getpid());: サーバー自身のプロセスID (PID) を表示します。クライアントはこのPIDを使用してメッセージを送信します。|
|sa.sa_flags = SA_SIGINFO;: handle_signal関数がsiginfo_t構造体を受け取る拡張シグナルハンドラであることを指定します。|
|sa.sa_sigaction = handle_signal;: handle_signal関数をシグナルハンドラとして割り当てます。|
|sigemptyset(&sa.sa_mask);: シグナルハンドラ実行中にブロックされるシグナルマスクをクリアします。|
|if (sigaction(SIGUSR1| &sa| NULL) == -1): SIGUSR1シグナルが受信されたときにhandle_signalが呼び出されるように登録します。失敗した場合はエラーメッセージを表示して終了します。|
|else if (sigaction(SIGUSR2| &sa| NULL) == -1): SIGUSR2シグナルが受信されたときにhandle_signalが呼び出されるように登録します。失敗した場合はエラーメッセージを表示して終了します。|
|while (1) pause();: サーバーを無限ループに入れます。pause()関数は、シグナルが受信されるまでプロセスを一時停止させます。シグナルが受信されると、登録されたhandle_signalが実行され、その後pause()は再開し、再びシグナルを待ちます。これにより、CPUを消費することなく効率的にシグナルを待機できます。|
|UNIX シグナルの理解（サーバーの視点）|
|サーバーは、クライアントからのシグナルを受信し、それらを解釈する役割を担います。|
|getpid(): サーバー自身のプロセスIDを取得するために使用されます。この PID は、クライアントがメッセージを送信する際に必要になります。|
|sigaction(): シグナルハンドラを設定するための推奨される関数です。サーバーはSIGUSR1とSIGUSR2の両方に対して同じhandle_signal関数を登録します。SA_SIGINFOフラグを使用することで、シグナルを送信したクライアントのPID (info->si_pid) を取得できるようになります。これは、サーバーがクライアントに確認応答を返すために不可欠です。|
|sigqueue(): クライアントに確認応答シグナルを送信するために使用されます。kill()関数よりも高機能で、追加のデータ（sigval）をシグナルとともに送信できますが、Minitalkでは主に確認応答の目的で使用されます。|
|pause(): main関数の無限ループ内で使用され、サーバーがCPUを浪費することなくシグナルを効率的に待機できるようにします。シグナルが到着すると、pause()は中断され、シグナルハンドラが実行された後、再びpause()が呼び出され、次のシグナルを待ちます。|
|サーバーのメッセージ処理フロー:|
|サーバーが起動し、自身のPIDを表示します。|
|SIGUSR1とSIGUSR2のシグナルハンドラとしてhandle_signal関数を登録します。|
|while(1) pause();ループに入り、クライアントからのシグナルを待ちます。|
|クライアントからSIGUSR1またはSIGUSR2シグナルを受信するたびに、handle_signalが呼び出されます。|
|handle_signal内で、受信したシグナルが現在の文字のビットとして組み立てられます。|
|8ビット（1文字）が完全に受信されると、process_byteが呼び出され、文字がバッファに格納されるか、メッセージが完了した場合は表示されます。|
|文字が処理された後、サーバーはsigqueueを使用してクライアントにSIGUSR1シグナルを送信し、確認応答を返します。|
|handle_signalは静的変数をリセットし、次の文字の受信準備をします。|
|サーバーはpause()に戻り、次のシグナルを待ちます。|
|このプロセスにより、クライアントとサーバー間の信頼性の高い、ビットごとの通信が実現されます。|
