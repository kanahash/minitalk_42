# Minitalk クライアント (`client.c`)

この`client.c`ファイルは、Minitalkプロジェクトの一部であり、**UNIXシグナル**を使ったプロセス間通信 (IPC) の基本的なクライアント・サーバーアプリケーションを実装しています。クライアントは、各文字を`SIGUSR1`および`SIGUSR2`シグナルの連続としてエンコードし、サーバーにメッセージを送信します。

---

## 関数解説

このクライアントプログラムで使用されている各関数について、詳しく見ていきましょう。

### `get_ack_ptr(void)`

* **目的**: この**静的**関数は、`ack`という名前の`volatile sig_atomic_t`型変数へのポインタを提供します。この変数は、サーバーから**確認応答 (acknowledgment)** シグナルが受信されたかどうかを示すフラグとして機能します。
* **重要な概念**:
    * `static volatile sig_atomic_t ack = 0;`:
        * `static`: 変数`ack`は一度だけ初期化され、`get_ack_ptr`への複数回の呼び出しにわたってその値を保持します。
        * `volatile`: このキーワードは、`ack`の値が予期せず（例えば、シグナルハンドラによって）変更される可能性があることをコンパイラに伝えます。これにより、コンパイラが変数の読み取りを最適化して省略するのを防ぎます。
        * `sig_atomic_t`: この型での操作は**アトミック**に実行されることが保証されます。つまり、それらの操作は単一の不可分なステップで実行されるため、シグナルハンドラ内で変更される変数において、**競合状態 (race condition)** を防ぐ上で非常に重要です。

### `act_handler(int sig, siginfo_t *info, void *ucontext)`

* **目的**: これは**シグナルハンドラ**関数です。クライアントプロセスがサーバーから`SIGUSR1`または`SIGUSR2`シグナルを受信すると、オペレーティングシステムによって呼び出されます。その主な役割は、確認応答が受信されたことを示すために、`ack`フラグを1に設定することです。
* **パラメータ**:
    * `int sig`: 受信したシグナルの番号（`SIGUSR1`または`SIGUSR2`）。
    * `siginfo_t *info`: `siginfo_t`構造体へのポインタで、送信元プロセスのPIDを含むシグナルに関する詳細情報を提供します。（これらの最後の2つのパラメータは、`(void)`キャストで示されているように、単純なシグナルハンドラでは通常使用されません。）
    * `void *ucontext`: シグナルが配信された時点のユーザーコンテキストを表す`ucontext_t`構造体へのポインタ。
* **機能**: `act_handler`が呼び出されると、`get_ack_ptr()`を使用して`ack`ポインタを取得し、`*ack_ptr`を1に設定します。

### `send_char(pid_t server_pid, char c)`

* **目的**: この関数は、指定された`server_pid`を持つサーバープロセスに、単一の文字`c`を送信する役割を担います。文字をビットごとに送信します。
* **メカニズム**:
    * **ビットごとの送信**: 文字`c`の最上位ビット（7）から最下位ビット（0）までを反復処理します。
    * **シグナルマッピング**:
        * 現在のビットが1の場合、`server_pid`に`SIGUSR1`を送信します。
        * 現在のビットが0の場合、`server_pid`に`SIGUSR2`を送信します。
    * **エラー処理**: `kill()`の戻り値をチェックします。`kill()`が-1を返した場合、エラーを示しており、クライアントは終了します。
    * **遅延 (`usleep(SLEEP)`)**: 各ビットを送信した後に、短い遅延（`SLEEP`）が導入されます。これは、シグナルが速すぎると、サーバーが各シグナルを処理するのに十分な時間がなく、シグナルが失われたり順序が狂ったりするのを防ぐために非常に重要です。`SLEEP`定数は`minitalk.h`で定義されているはずです。
    * **確認応答 (ACK) 待ち**: 文字の8ビットすべてを送信した後、クライアントはサーバーからの確認応答シグナルを待つループ (`while (!(*ack_ptr)) pause();`) に入ります。`pause()`関数は、シグナルが捕捉されるまでプロセスをスリープ状態にします。`act_handler`が`*ack_ptr`を1に設定すると、ループが中断されます。
    * **ACKのリセット**: 確認応答を受信した後、次の文字のために`*ack_ptr`は0にリセットされます。

### `send_msg(pid_t server_pid, char *msg)`

* **目的**: この関数は、指定された`server_pid`を持つサーバーに、文字列`msg`全体を送信します。
* **メカニズム**: `msg`文字列の各文字を反復処理し、各文字に対して`send_char()`を呼び出します。
* **ナル終端文字**: 文字列内のすべての文字を送信した後、明示的に`send_char(server_pid, '\0');`を呼び出して**ナル終端文字**（`\0`）を送信します。これは、メッセージの終わりをサーバーに伝え、サーバーがメッセージ全体を受信したことを認識できるようにします。

### `main(int ac, char **av)`

* **目的**: これはクライアントプログラムのエントリポイントです。引数の解析、PIDの検証、シグナルハンドラのセットアップ、およびメッセージの送信を処理します。
* **引数処理**:
    * 2つのコマンドライン引数（サーバーのPIDと送信するメッセージ）を期待します。
    * `ac != 3`: 正しい数の引数が提供されているかをチェックします。提供されていない場合、エラーメッセージを表示して終了します。
    * `ft_atoi(av[1])`: 最初の引数（サーバーPID）を文字列から整数に変換します。`ft_atoi`は、おそらく`libft`ライブラリのカスタム関数です。
    * `pid <= 0`: PIDが正の値であることを検証します。
* **シグナルハンドラのセットアップ**:
    * `struct sigaction sa;`: シグナルがどのように処理されるかを定義するために使用される`sigaction`構造体を宣言します。
    * `ft_memset(&sa, 0, sizeof(sa));`: `sigaction`構造体のすべてのメンバーをゼロで初期化します。`ft_memset`は別のカスタム関数です。
    * `sa.sa_flags = SA_SIGINFO;`: このフラグを設定することで、`sa_sigaction`メンバー（関数ポインタ）がシグナルハンドラとして使用され、追加情報を含む`siginfo_t`ポインタを受け取るように指定します。
    * `sa.sa_sigaction = act_handler;`: `act_handler`関数をシグナルハンドラとして割り当てます。
    * `sigemptyset(&sa.sa_mask);`: シグナルマスクをクリアします。これにより、`act_handler`の実行中に他のシグナルがブロックされなくなります。
    * `sigaction(SIGUSR1, &sa, NULL) == -1` および `sigaction(SIGUSR2, &sa, NULL) == -1`: `SIGUSR1`または`SIGUSR2`のどちらかが受信されたときに`act_handler`が呼び出されるように登録します。登録に失敗した場合、プログラムは1を返します。
* **メッセージ送信**:
    * `if (*av[2])`: メッセージ文字列が空でないことを確認します。
    * `send_msg(pid, av[2]);`: 提供されたメッセージをサーバーに送信するために`send_msg`を呼び出します。

---

## UNIX シグナルの理解

### シグナルとは？

UNIXライクなオペレーティングシステムにおいて、**シグナル**はプロセス間通信 (IPC) の一種であり、プロセスにイベントを通知するために使われます。シグナルは非同期であり、いつでも到着する可能性があり、プログラムの通常の実行フローを中断させます。これらは、ハードウェア例外からソフトウェアイベントまで、さまざまなイベントを処理するための基本的なメカニズムです。

シグナルは「ソフトウェア割り込み」のようなものだと考えてください。シグナルがプロセスに送信されると、オペレーティングシステムはそのプロセスの通常の実行を中断させ、シグナルを処理させます。

### シグナルの一般的な用途:

* **プロセス管理**: プロセスの終了 (`SIGTERM`, `SIGKILL`)、一時停止 (`SIGSTOP`, `SIGTSTP`)、再開 (`SIGCONT`)。
* **エラー処理**: 不正なメモリアクセス (`SIGSEGV`)、ゼロ除算 (`SIGFPE`) など、エラーをプロセスに通知します。
* **非同期イベント**: 子プロセスの終了 (`SIGCHLD`) やタイマーの期限切れ (`SIGALRM`) などをプロセスに通知します。
* **プロセス間通信 (IPC)**: Minitalkで見られるように、シグナルはプロセス間の単純な通信に使用できます。`SIGUSR1`と`SIGUSR2`は、特にユーザー定義の目的に設計されています。

### シグナルに関連する主要な概念:

* **シグナル番号**: 各シグナルには一意の整数識別子があります（例: `SIGTERM`は15、`SIGKILL`は9）。
* **シグナルハンドラ**: 特定のシグナルがプロセスによって受信されたときに実行される関数です。カスタムハンドラが定義されていない場合、システムはデフォルトのアクション（例: プロセスを終了させる）を実行します。
* **シグナルの送信**:
    * `kill(pid_t pid, int sig)`: `pid`で識別されるプロセスにシグナル`sig`を送信します。
    * `raise(int sig)`: 呼び出し元のプロセス自身にシグナル`sig`を送信します。
    * `alarm(unsigned int seconds)`: 指定された秒数後に、呼び出し元のプロセスに`SIGALRM`シグナルを送信します。
* **シグナルの受信 / シグナルハンドリング**:
    * `signal(int signum, void (*handler)(int))`: シグナルハンドラを登録するための古くてシンプルな関数です。シグナルキューイングや競合状態に関して制限があります。
    * `sigaction(int signum, const struct sigaction *act, struct sigaction *oldact)`: シグナルハンドリングのためのより堅牢で推奨される関数です。シグナル動作をより詳細に制御できます。これには以下が含まれます:
        * `sa_handler`または`sa_sigaction`: シグナル処理関数へのポインタ。`SA_SIGINFO`フラグで示されているように、シグナルに関するより多くの情報（送信者のPIDなど）が必要な場合は`sa_sigaction`が使われます。
        * `sa_mask`: シグナルハンドラの実行中にブロック（マスク）されるシグナルのセットです。これにより、再入問題を防ぎます。
        * `sa_flags`: シグナルハンドラの動作を変更するさまざまなフラグ（例: 中断されたシステムコールを自動的に再開するための`SA_RESTART`、拡張シグナル情報のための`SA_SIGINFO`）。
* **シグナルのブロック (シグナルマスク)**: プロセスは、特定のシグナルが配信されるのを一時的にブロックできます。ブロックされたシグナルは保留され、ブロックが解除されると配信されます。
    * `sigprocmask()`: 呼び出し元のプロセスのシグナルマスクを調べたり変更したりするために使用されます。
    * `sigemptyset()`, `sigaddset()`, `sigdelset()`, `sigfillset()`: シグナルセットを操作するための関数です。
* **アトミック性 (`sig_atomic_t`)**: シグナルハンドラ内で変数が変更され、かつメインプログラムフローでもアクセスされる場合、競合状態のリスクがあります。`sig_atomic_t`は、そのような変数に対する操作がアトミックであることを保証し、データ破損を防ぎます。
* `pause()`: このシステムコールは、シグナルが捕捉されるまで、呼び出し元のプロセスの実行を一時停止します。`send_char`関数で見られるように、イベントを効率的に待つためにシグナルハンドラと組み合わせてよく使用されます。

### Minitalkにおけるシグナル:

Minitalkプロジェクトでは、`SIGUSR1`と`SIGUSR2`が特に選択されています。これらは**ユーザー定義シグナル**だからです。これは、これらのシグナルのデフォルトの動作は通常プロセスを終了させることですが、主にアプリケーション固有の用途のために意図されていることを意味します。

* クライアントは、文字を送信する際に、`SIGUSR1`を1ビット、`SIGUSR2`を0ビットとして使用します。
* サーバーはこれらのシグナルを受信し、ビットを文字に再構築し、その後、各文字の受信を確認するためにクライアントに確認応答シグナル（これも`SIGUSR1`または`SIGUSR2`である可能性が高いですが、これはサーバー側で処理され、このクライアントコードには示されていません）を送信します。この確認応答メカニズムは、信頼性の高い通信のために不可欠です。

